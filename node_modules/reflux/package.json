{
  "name": "reflux",
  "version": "0.2.3",
  "description": "A simple library for uni-directional dataflow application architecture inspired by ReactJS Flux",
  "main": "index.js",
  "scripts": {
    "test": "grunt test",
    "benchmark": "node test/benchmarks"
  },
  "author": {
    "name": "Mikael Brassman"
  },
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "http://github.com/spoike/reflux.git"
  },
  "dependencies": {
    "eventemitter3": "^0.1.2"
  },
  "devDependencies": {
    "benchmark": "^1.0.0",
    "browserify": "^5.11.1",
    "chai": "^1.9.1",
    "chai-as-promised": "^4.1.1",
    "grunt": "^0.4.5",
    "grunt-browserify": "^2.1.4",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-uglify": "^0.5.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-mocha-test": "^0.11.0",
    "matchdep": "^0.3.0",
    "mocha": "^1.21.3",
    "q": "^1.0.1",
    "sinon": "^1.10.3",
    "karma-commonjs": "0.0.11",
    "karma": "0.12.23",
    "karma-mocha": "^0.1.9",
    "karma-phantomjs-launcher": "^0.1.4",
    "karma-bro": "^0.7.0",
    "karma-spec-reporter": "0.0.13",
    "grunt-karma": "^0.9.0",
    "karma-sauce-launcher": "^0.2.10"
  },
  "readme": "# RefluxJS\n\nA simple library for unidirectional dataflow architecture inspired by ReactJS [Flux](http://facebook.github.io/react/blog/2014/05/06/flux.html).\n\n[![NPM Version][npm-image]][npm-url]\n[![NPM Downloads][downloads-image]][npm-url]\n[![Bower Version][bower-image]][bower-url]\n[![Dependencies][dependencies-image]][npm-url]\n[![Build Status][travis-image]][travis-url]\n[![Gratipay][gratipay-image]][gratipay-url]\n\nYou can read an overview of Flux [here](http://facebook.github.io/react/docs/flux-overview.html), however the gist of it is to introduce a more functional programming style architecture by eschewing MVC like pattern and adopting a single data flow pattern.\n\n```\n╔═════════╗       ╔════════╗       ╔═════════════════╗\n║ Actions ║──────>║ Stores ║──────>║ View Components ║\n╚═════════╝       ╚════════╝       ╚═════════════════╝\n     ^                                      │\n     └──────────────────────────────────────┘\n\n```\n\nThe pattern is composed of actions and data stores, where actions initiate new data to pass through data stores before coming back to the view components again. If a view component has an event that needs to make a change in the application's data stores, they need to do so by signalling to the stores through the actions available.\n\n## Comparing RefluxJS with Facebook Flux\n\nThe goal of the refluxjs project is to get this architecture easily up and running in your web application, both client-side or server-side. There are some differences between how this project works and how Facebook's proposed Flux architecture works:\n\nYou can read more in this [blog post about React Flux vs Reflux](http://spoike.ghost.io/deconstructing-reactjss-flux/).\n\n### Similarities with Flux\n\nSome concepts are still in Reflux in comparison with Flux:\n\n* There are actions\n* There are data stores\n* The data flow is unidirectional\n\n### Differences with Flux\n\nReflux has refactored Flux to be a bit more dynamic and be more Functional Reactive Programming (FRP) friendly:\n\n* The singleton dispatcher is removed in favor for letting every action act as dispatcher instead.\n* Because actions are listenable, the stores may listen to them. Stores don't need to have a big switch statements that does static type checking (of action types) with strings\n* Stores may listen to other stores, i.e. it is possible to create stores that can *aggregate data further*, similar to a map/reduce.\n* `waitFor` is replaced in favor to handle *serial* and *parallel* data flows:\n * **Aggregate data stores** (mentioned above) may listen to other stores in *serial*\n * **Joins** for joining listeners in *parallel*\n* *Action creators* are not needed because RefluxJS actions are functions that will pass on the payload they receive to anyone listening to them\n\n## Examples\n\nYou can find some example projects at these locations:\n\n* [Todo Example Project](https://github.com/spoike/refluxjs-todo) - [http://spoike.github.io/refluxjs-todo/](http://spoike.github.io/refluxjs-todo/)\n\n## Installation\n\nYou can currently install the package as a npm package or bower.\n\n### NPM\n\nThe following command installs reflux as an npm package:\n\n    npm install reflux\n\n### Bower\n\nThe following command installs reflux as a bower component that can be used in the browser:\n\n    bower install reflux\n\n### ES5\n\nLike React, Reflux depends on an es5-shim for older browsers. The es5-shim.js from [kriskowal's es5-shim](https://github.com/kriskowal/es5-shim) provides everything required.\n\n## Usage\n\nFor a full example check the [`test/index.js`](test/index.js) file.\n\n### Creating actions\n\nCreate an action by calling `Reflux.createAction` with an optional options object.\n\n```javascript\nvar statusUpdate = Reflux.createAction(options);\n```\n\nAn action is a functor that can be invoked like any function.\n\n```javascript\nstatusUpdate(data); // Invokes the action statusUpdate\nstatusUpdate.triggerAsync(data); // same effect as above\n```\n\nIf `options.sync` is true, the functor will instead call `action.trigger` which is a synchronous operation. You can change `action.sync` during the lifetime of the action, and the following calls will honour that change.\n\nThere is also a convenience function for creating multiple actions.\n\n```javascript\nvar Actions = Reflux.createActions([\n    \"statusUpdate\",\n    \"statusEdited\",\n    \"statusAdded\"\n  ]);\n\n// Actions object now contains the actions\n// with the names given in the array above\n// that may be invoked as usual\n\nActions.statusUpdate();\n```\n\n#### Asynchronous actions\n\nFor actions that represent asynchronous operations (e.g. API calls), a few separate dataflows result from the operation. In the most typical case, we consider completion and failure of the operation. To create related actions for these dataflows, which you can then access as attributes, use `options.children`.\n\n```javascript\n// this creates 'load', 'load.completed' and 'load.failed'\nvar Actions = Reflux.createActions({\n    \"load\": {children: [\"completed\",\"failed\"]}\n});\n\n// when 'load' is triggered, call async operation and trigger related actions\nActions.load.listen( function() {\n    // By default, the listener is bound to the action\n    // so we can access child actions using 'this'\n    someAsyncOperation()\n        .then( this.completed )\n        .catch( this.failed );\n});\n```\n\nThere is a shorthand to define the `completed` and `failed` actions in the typical case: `options.asyncResult`. The following are equivalent:\n\n```javascript\ncreateAction({\n    children: [\"progressed\",\"completed\",\"failed\"]\n});\n\ncreateAction({\n    asyncResult: true,\n    children: [\"progressed\"]\n});\n```\n\nThere are a couple of helper methods available to trigger the `completed` and `failed` actions:\n\n* `promise` - Expects a promise object and binds the triggers of the `completed` and `failed` child actions to that promise, using `then()` and `catch()`.\n\n* `listenAndPromise` - Expects a function that returns a promise object, which is called when the action is triggered, after which `promise` is called with the returned promise object. Essentially calls the function on trigger of the action, which then triggers the `completed` or `failed` child actions after the promise is fulfilled.\n\nTherefore, the following are all equivalent:\n\n```javascript\nasyncResultAction.listen( function(arguments) {\n    someAsyncOperation(arguments)\n        .then(asyncResultAction.completed)\n        .catch(asyncResultAction.failed);\n});\n\nasyncResultAction.listen( function(arguments) {\n    asyncResultAction.promise( someAsyncOperation(arguments) );\n});\n\nasyncResultAction.listenAndPromise( someAsyncOperation );\n```\n\n#### Action hooks\n\nThere are a couple of hooks available for each action.\n\n* `preEmit` - Is called before the action emits an event. It receives the arguments from the action invocation. If it returns something other than undefined, that will be used as arguments for `shouldEmit` and subsequent emission.\n\n* `shouldEmit` - Is called after `preEmit` and before the action emits an event. By default it returns `true` which will let the action emit the event. You may override this if you need to check the arguments that the action receives and see if it needs to emit the event.\n\nExample usage:\n\n```javascript\nActions.statusUpdate.preEmit = function() { console.log(arguments); };\nActions.statusUpdate.shouldEmit = function(value) {\n    return value > 0;\n};\n\nActions.statusUpdate(0);\nActions.statusUpdate(1);\n// Should output: 1\n```\n\nYou can also set the hooks by sending them in a definition object as you create the action:\n\n```javascript\nvar action = Reflux.createAction({\n    preEmit: function(){...},\n    shouldEmit: function(){...}\n});\n```\n\n#### Reflux.ActionMethods\n\nIf you would like to have a common set of methods available to all actions you can extend the `Reflux.ActionMethods` object, which is mixed into the actions when they are created.\n\nExample usage:\n\n```javascript\nReflux.ActionMethods.exampleMethod = function() { console.log(arguments); };\n\nActions.statusUpdate.exampleMethod('arg1');\n// Should output: 'arg1'\n```\n\n### Creating data stores\n\nCreate a data store much like ReactJS's own `React.createClass` by passing a definition object to `Reflux.createStore`. You may set up all action listeners in the `init` function and register them by calling the store's own `listenTo` function.\n\n```javascript\n// Creates a DataStore\nvar statusStore = Reflux.createStore({\n\n    // Initial setup\n    init: function() {\n\n        // Register statusUpdate action\n        this.listenTo(statusUpdate, this.output);\n    },\n\n    // Callback\n    output: function(flag) {\n        var status = flag ? 'ONLINE' : 'OFFLINE';\n\n        // Pass on to listeners\n        this.trigger(status);\n    }\n\n});\n```\n\nIn the above example, whenever the action is called, the store's `output` callback will be called with whatever parameters was sent in the action. E.g. if the action is called as `statusUpdate(true)` then the flag argument in `output` function is `true`.\n\nA data store is a publisher much like the actions, so they too have the `preEmit` and `shouldEmit` hooks.\n\n#### Reflux.StoreMethods\n\nIf you would like to have a common set of methods available to all stores you can extend the `Reflux.StoreMethods` object, which is mixed into the stores when they are created.\n\nExample usage:\n\n```javascript\nReflux.StoreMethods.exampleMethod = function() { console.log(arguments); };\n\nstatusStore.exampleMethod('arg1');\n// Should output: 'arg1'\n```\n\n#### Mixins in stores\n\nJust as you can add mixins to React components, so it is possible to add your mixins to Store.\n\n```javascript\nvar MyMixin = { foo: function() { console.log('bar!'); } }\nvar Store = Reflux.createStore({\n    mixins: [MyMixin]\n});\nStore.foo(); // outputs \"bar!\" to console\n```\n\nMethods from mixins is available as well as the methods declared in the Store. So it's possible to access store's `this` from mixin, or methods of mixin from methods of store:\n\n```javascript\nvar MyMixin = { mixinMethod: function() { console.log(this.foo); } }\nvar Store = Reflux.createStore({\n    mixins: [MyMixin],\n    foo: 'bar!',\n    storeMethod: function() {\n        this.mixinMethod(); // outputs \"bar!\" to console\n    }\n});\n```\n\nA nice feature of mixins is that if a store is using multiple mixins and several mixins define the same lifecycle method (e.g. `init`, `preEmit`, `shouldEmit`), all of the lifecycle methods are guaranteed to be called.\n\n#### Listening to many actions at once\n\nSince it is a very common pattern to listen to all actions from a `createActions` call in a store `init` call, the store has a `listenToMany` function that takes an object of listenables. Instead of doing this:\n\n```javascript\nvar actions = Reflux.createActions([\"fireBall\",\"magicMissile\"]);\n\nvar Store = Reflux.createStore({\n    init: function() {\n        this.listenTo(actions.fireBall,this.onFireBall);\n        this.listenTo(actions.magicMissile,this.onMagicMissile);\n    },\n    onFireBall: function(){\n        // whoooosh!\n    },\n    onMagicMissile: function(){\n        // bzzzzapp!\n    }\n});\n```\n\n...you can do this:\n\n```javascript\nvar actions = Reflux.createActions([\"fireBall\",\"magicMissile\"]);\n\nvar Store = Reflux.createStore({\n    init: function() {\n        this.listenToMany(actions);\n    },\n    onFireBall: function(){\n        // whoooosh!\n    },\n    onMagicMissile: function(){\n        // bzzzzapp!\n    }\n});\n```\n\nThis will add listeners to all actions `actionName` who have a corresponding `onActionName` (or `actionName` if you prefer) method in the store. Thus if the `actions` object should also have included an `iceShard` spell, that would simply be ignored.\n\n#### The listenables shorthand\n\nTo make things more convenient still, if you give an object of actions to the `listenables` property of the store definition, that will be automatically passed to `listenToMany`. So the above example can be simplified even further:\n\n```javascript\nvar actions = Reflux.createActions([\"fireBall\",\"magicMissile\"]);\n\nvar Store = Reflux.createStore({\n    listenables: actions,\n    onFireBall: function(){\n        // whoooosh!\n    },\n    onMagicMissile: function(){\n        // bzzzzapp!\n    }\n});\n```\n\nThe `listenables` property can also be an array of such objects, in which case all of them will be sent to `listenToMany`. This allows you to do convenient things like this:\n\n```javascript\nvar Store = Reflux.createStore({\n    listenables: [require('./darkspells'),require('./lightspells'),{healthChange:require('./healthstore')}],\n    // rest redacted\n});\n```\n\n### Listening to changes in data store\n\nIn your component, register to listen to changes in your data store like this:\n\n```javascript\n// Fairly simple view component that outputs to console\nfunction ConsoleComponent() {\n\n    // Registers a console logging callback to the statusStore updates\n    statusStore.listen(function(status) {\n        console.log('status: ', status);\n    });\n};\n\nvar consoleComponent = new ConsoleComponent();\n```\n\nInvoke actions as if they were functions:\n\n```javascript\nstatusUpdate(true);\nstatusUpdate(false);\n```\n\nWith the setup above this will output the following in the console:\n\n```\nstatus:  ONLINE\nstatus:  OFFLINE\n```\n### React component example\n\nRegister your component to listen for changes in your data stores, preferably in the `componentDidMount` [lifecycle method](http://facebook.github.io/react/docs/component-specs.html) and unregister in the `componentWillUnmount`, like this:\n\n```javascript\nvar Status = React.createClass({\n    initialize: function() { },\n    onStatusChange: function(status) {\n        this.setState({\n            currentStatus: status\n        });\n    },\n    componentDidMount: function() {\n        this.unsubscribe = statusStore.listen(this.onStatusChange);\n    },\n    componentWillUnmount: function() {\n        this.unsubscribe();\n    },\n    render: function() {\n        // render specifics\n    }\n});\n```\n\n#### Convenience mixin for React\n\nYou always need to unsubscribe components from observed actions and stores upon\nunmounting. To simplify this process you can use [mixins in React](http://facebook.github.io/react/docs/reusable-components.html#mixins). There is a convenience mixin available at `Reflux.ListenerMixin`. Using that, the above example can be written like thus:\n\n```javascript\nvar Status = React.createClass({\n    mixins: [Reflux.ListenerMixin],\n    onStatusChange: function(status) {\n        this.setState({\n            currentStatus: status\n        });\n    },\n    componentDidMount: function() {\n        this.listenTo(statusStore, this.onStatusChange);\n    },\n    render: function() {\n        // render specifics\n    }\n});\n```\n\nThe mixin provides the `listenTo` method for the React component, that works much like the one found in the Reflux's stores, and handles the listeners during mount and unmount for you. You also get the same `listenToMany` method as the store has.\n\n\n#### Using Reflux.listenTo\n\nIf you're not reliant on any special logic for the `this.listenTo` calls inside `componentDidMount`, you can instead use a call to `Reflux.listenTo` as a mixin. That will automatically set up the `componentDidMount` and the rest for you, as well as add the `ListenerMixin` functionality. With this our example above can be reduced even further:\n\n```javascript\nvar Status = React.createClass({\n    mixins: [Reflux.listenTo(statusStore,\"onStatusChange\")],\n    onStatusChange: function(status) {\n        this.setState({\n            currentStatus: status\n        });\n    },\n    render: function() {\n        // render using `this.state.currentStatus`\n    }\n});\n```\n\nYou can have multiple calls to `Reflux.listenTo` in the same `mixins` array.\n\nThere is also `Reflux.listenToMany` which works in exactly the same way, exposing `listener.listenToMany`.\n\n#### Using Reflux.connect\n\nIf all you want to do is update the state of your component to whatever the data store transmits, you can use `Reflux.connect(listener,[stateKey])` as a mixin. If you supply a `stateKey` the state will be updated through `this.setState({<stateKey>:data})`, otherwise `this.setState(data)`. Here's the example above changed to use this syntax:\n\n```javascript\nvar Status = React.createClass({\n    mixins: [Reflux.connect(statusStore,\"currentStatus\")],\n    render: function() {\n        // render using `this.state.currentStatus`\n    }\n});\n```\n\n### Listening to changes in other data stores (aggregate data stores)\n\nA store may listen to another store's change, making it possible to safely chain stores for aggregated data without affecting other parts of the application. A store may listen to other stores using the same `listenTo` function as with actions:\n\n```javascript\n// Creates a DataStore that listens to statusStore\nvar statusHistoryStore = Reflux.createStore({\n    init: function() {\n\n        // Register statusStore's changes\n        this.listenTo(statusStore, this.output);\n\n        this.history = [];\n    },\n\n    // Callback\n    output: function(statusString) {\n        this.history.push({\n            date: new Date(),\n            status: statusString\n        });\n        // Pass the data on to listeners\n        this.trigger(this.history);\n    }\n\n});\n```\n## Advanced usage\n\n### Switching EventEmitter\n\nDon't like to use the EventEmitter provided? You can switch to another one, such as NodeJS's own like this:\n\n```javascript\n// Do this before creating actions or stores\n\nReflux.setEventEmitter(require('events').EventEmitter);\n```\n\n### Switching nextTick\n\nWhenever action functors are called, they return immediately through the use of `setTimeout` (`nextTick` function) internally.\n\nYou may switch out for your favorite `setTimeout`, `nextTick`, `setImmediate`, et al implementation:\n\n```javascript\n\n// node.js env\nReflux.nextTick(process.nextTick);\n```\n\nFor better alternative to `setTimeout`, you may opt to use the [`setImmediate` polyfill](https://github.com/YuzuJS/setImmediate).\n\n\n### Joining parallel listeners with composed listenables\n\nThe Reflux API contains `join` methods that makes it easy to aggregate publishers that emit events in parallel. This corresponds to the `waitFor` method in Flux.\n\n#### Argument tracking\n\nA join is triggered once all participating publishers have emitted at least once. The callback will be called with the data from the various emissions, in the same order as the publishers were listed when the join was created.\n\nThere are four join methods, each representing a different strategy to track the emission data:\n\n*    `joinLeading`: Only the first emission from each publisher is saved. Subsequent emissions by the same publisher before all others are finished are ignored.\n*    `joinTrailing`: If a publisher triggers twice, the second emission overwrites the first.\n*    `joinConcat`: An array of emission arguments are stored for each publisher.\n*    `joinStrict`: An error is thrown if a publisher emits twice before the join is completed.\n\nThe method signatures all look like this:\n\n```javascript\njoinXyz(...publisher,callback)\n```\n\nOnce a join is triggered it will reset, and thus it can trigger again when all publishers have emitted anew.\n\n#### Using the listener instance methods\n\nAll objects using the listener API (stores, React components using `ListenerMixin`, or other components using the `ListenerMethods`) gain access to the four join instance methods, named after the argument strategy. Here's an example saving the last emission from each publisher:\n\n```javascript\nvar gainHeroBadgeStore = Reflux.createStore({\n    init: function() {\n        this.joinTrailing(actions.disarmBomb, actions.saveHostage, actions.recoverData, this.triggerAsync);\n    }\n});\n\nactions.disarmBomb(\"warehouse\");\nactions.recoverData(\"seedyletter\");\nactions.disarmBomb(\"docks\");\nactions.saveHostage(\"offices\",3);\n// `gainHeroBadgeStore` will now asyncronously trigger `[[\"docks\"],[\"offices\",3],[\"seedyletter\"]]`.\n```\n\n#### Using the static methods\n\nSince it is rather common to have a store where the only purpose is to listen to a join and trigger when the join is completed, the join methods have static counterparts on the `Reflux` object which return stores listening to the requested join. Using them, the store in the example above could instead be created like this:\n\n```javascript\nvar gainHeroBadgeStore = Reflux.joinTrailing(actions.disarmBomb, actions.saveHostage, actions.recoverData);\n```\n\n### Sending initial state with the listenTo function\n\nThe `listenTo` function provided by the `Store` and the `ListenerMixin` has a third parameter that accepts a callback. This callback will be invoked when the listener is registered with whatever the `getInitialState` is returning.\n\n```javascript\nvar exampleStore = Reflux.createStore({\n    init: function() {},\n    getInitialState: function() {\n        return \"the initial data\";\n    }\n});\n\n// Anything that will listen to the example store\nthis.listenTo(exampleStore, onChangeCallback, initialCallback)\n\n// initialCallback will be invoked immediately with \"the initial data\" as first argument\n```\n\nRemember the `listenToMany` method? In case you use that with other stores, it supports `getInitialState`. That data is sent to the normal listening callback, or a `this.on<Listenablename>Default` method if that exists.\n\n## Colophon\n\n[List of contributors](https://github.com/spoike/reflux/graphs/contributors) is available on Github.\n\nThis project is licensed under [BSD 3-Clause License](http://opensource.org/licenses/BSD-3-Clause). Copyright (c) 2014, Mikael Brassman.\n\nFor more information about the license for this particular project [read the LICENSE.md file](LICENSE.md).\n\nThis project uses [eventemitter3](https://github.com/3rd-Eden/EventEmitter3), is currently MIT licensed and [has it's license information here](https://github.com/3rd-Eden/EventEmitter3/blob/master/LICENSE).\n\n[npm-image]: http://img.shields.io/npm/v/reflux.svg\n[downloads-image]: http://img.shields.io/npm/dm/reflux.svg\n[dependencies-image]: http://img.shields.io/david/spoike/refluxjs.svg\n[npm-url]: https://www.npmjs.org/package/reflux\n[bower-image]: http://img.shields.io/bower/v/reflux.svg\n[bower-url]: http://bower.io/search/?q=reflux\n[travis-image]: http://img.shields.io/travis/spoike/refluxjs/master.svg\n[travis-url]: https://travis-ci.org/spoike/refluxjs\n[gratipay-image]: http://img.shields.io/gratipay/spoike.svg\n[gratipay-url]: https://gratipay.com/spoike/\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/spoike/reflux/issues"
  },
  "homepage": "https://github.com/spoike/reflux",
  "_id": "reflux@0.2.3",
  "_shasum": "484fe5ab54a29267194ad491d79249780db72120",
  "_from": "reflux@",
  "_resolved": "https://registry.npmjs.org/reflux/-/reflux-0.2.3.tgz"
}
